class CFG():
    def __init__(self, grammar):
        self.grammar = grammar
        self.rules = self.parse_grammar(grammar)
        self.is_cnf = self.check_if_cnf()
        self.cnf_grammar = None
        if not self.is_cnf:
            self.cnf_grammar = CNF(self.grammar).get_cnf_grammar()
        else:
            self.cnf_grammar = self.rules
    
    def parse_grammar(self, grammar):
        """
        Parses the grammar rules from a list of strings.
        
        Args:
        grammar (list of str): The list of grammar rules in the form "LHS -> RHS".
        
        Returns:
        dict: A dictionary where keys are the left-hand side (LHS) of the rules
              and values are lists of right-hand side (RHS) alternatives.
        """
        rules = {}
        for rule in grammar:
            lhs, rhs = rule.split("->")
            lhs = lhs.strip()
            rhs = [r.strip() for r in rhs.split("|")]
            rules[lhs] = rhs
        return rules

    def check_if_cnf(self):
        """
        Checks if the given grammar is in Chomsky Normal Form (CNF).
        
        Returns:
        bool: True if the grammar is in CNF, False otherwise.
        """
        rules = self.rules
        for lhs, rhs_list in rules.items():
            for rhs in rhs_list:
                if len(rhs) == 1:
                    # Single terminal symbol (must be lowercase)
                    if not rhs.islower():  # rhs is a single terminal
                        return False
                elif len(rhs) == 2:
                    # Two symbols (both must be non-terminals)
                    if not (rhs[0].isupper() and rhs[1].isupper()):
                        return False
                else:
                    return False  # If there are more than 2 symbols on the right-hand side, it's not CNF
        return True  # If all checks passed, it's CNF

    def cky_algorithm(self, word):
        """
        Implements the Cocke-Kasami-Younger (CKY) algorithm to determine if a word 
        can be generated by a given grammar.

        Args:
        word (str): The word to be tested.

        Returns:
        bool: True if the word can be generated by the grammar, False otherwise.
        """
        rules = self.cnf_grammar  # Use the CNF grammar
        n = len(word)
        table = [[set() for _ in range(n)] for _ in range(n)]

        # Fill the diagonal of the table
        for j in range(n):
            for lhs, rhs_list in rules.items():
                for rhs in rhs_list:
                    if rhs == word[j]:
                        table[j][j].add(lhs)

            # Handle unit productions for the diagonal
            self.handle_unit_productions(j, j, table)

        # Fill the rest of the table
        for span in range(2, n + 1):
            for i in range(n - span + 1):
                j = i + span - 1
                for k in range(i, j):
                    for lhs, rhs_list in rules.items():
                        for rhs in rhs_list:
                            if len(rhs) == 2:
                                B, C = rhs
                                if B in table[i][k] and C in table[k + 1][j]:
                                    table[i][j].add(lhs)

                # Handle unit productions for the current cell
                self.handle_unit_productions(i, j, table)

        return 'S' in table[0][n-1]

    def handle_unit_productions(self, i, j, table):
        """
        Handles the addition of unit productions in the CKY table.

        Args:
        i (int): The row index in the CKY table.
        j (int): The column index in the CKY table.
        table (list of list of set): The CKY table.
        """
        rules = self.cnf_grammar  # Use the CNF grammar
        added = True
        while added:
            added = False
            for lhs, rhs_list in rules.items():
                for rhs in rhs_list:
                    if len(rhs) == 1 and rhs in table[i][j]:
                        if lhs not in table[i][j]:
                            table[i][j].add(lhs)
                            added = True


class CNF():
    def __init__(self, grammar):
        self.grammar = grammar
        self.rules = self.parse_grammar(grammar)
        self.existing_nonterminals = set(self.rules.keys())
        self.cnf_grammar = self.transform_to_CNF()
    
    def parse_grammar(self, grammar):
        """
        Parses the grammar rules from a list of strings.
        
        Args:
        grammar (list of str): The list of grammar rules in the form "LHS -> RHS".
        
        Returns:
        dict: A dictionary where keys are the left-hand side (LHS) of the rules
              and values are lists of right-hand side (RHS) alternatives.
        """
        rules = {}
        for rule in grammar:
            lhs, rhs = rule.split("->")
            lhs = lhs.strip()
            rhs = [r.strip() for r in rhs.split("|")]
            rules[lhs] = rhs
        return rules

    def get_unique_nonterminal(self):
        """
        Generates a unique non-terminal symbol that does not exist in the current set.
        
        Returns:
        str: A unique non-terminal symbol.
        """
        for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
            if letter not in self.existing_nonterminals:
                self.existing_nonterminals.add(letter)
                return letter
        raise ValueError("Ran out of unique non-terminal symbols")

    def remove_null_productions(self):
        """
        Removes null productions from the grammar.
        
        Returns:
        dict: The updated grammar rules without null productions.
        """
        rules = self.rules
        nullable = set()

        # Step 1: Find nullable variables
        for lhs, rhs_list in rules.items():
            for rhs in rhs_list:
                if rhs == "":
                    nullable.add(lhs)

        changed = True
        while changed:
            changed = False
            for lhs, rhs_list in rules.items():
                for rhs in rhs_list:
                    if all(symbol in nullable for symbol in rhs):
                        if lhs not in nullable:
                            nullable.add(lhs)
                            changed = True

        # Step 2: Remove null productions and add new rules
        new_rules = {}
        for lhs, rhs_list in rules.items():
            new_rhs_list = set()
            for rhs in rhs_list:
                if rhs != "":
                    # Add the production without changes
                    new_rhs_list.add(rhs)
                    # Add productions omitting nullable variables
                    subsets = self.get_nullable_subsets(rhs, nullable)
                    new_rhs_list.update(subsets)
            new_rules[lhs] = list(new_rhs_list)

        self.rules = new_rules

    def get_nullable_subsets(self, rhs, nullable):
        """
        Generates all possible subsets of RHS by omitting nullable variables.
        
        Args:
        rhs (str): The right-hand side of a production.
        nullable (set): The set of nullable variables.
        
        Returns:
        set: A set of new RHS strings with nullable variables omitted.
        """
        if not rhs:
            return {""}
        first, rest = rhs[0], rhs[1:]
        subsets = self.get_nullable_subsets(rest, nullable)
        if first in nullable:
            return subsets | {first + subset for subset in subsets}
        else:
            return {first + subset for subset in subsets}

    def unitary_rule(self):
        """
        Removes unit productions from the grammar.
        
        Returns:
        dict: The updated grammar rules without unit productions.
        """
        rules = self.rules
        unit_productions = [(lhs, rhs[0]) for lhs, rhs_list in rules.items() for rhs in rhs_list if len(rhs) == 1 and rhs.isupper()]
        while unit_productions:
            lhs, unit = unit_productions.pop()
            if lhs != unit:
                if lhs not in rules:
                    rules[lhs] = []
                for rhs in rules[unit]:
                    if rhs not in rules[lhs]:
                        rules[lhs].append(rhs)
                        if len(rhs) == 1 and rhs.isupper():
                            unit_productions.append((lhs, rhs))
                rules[lhs] = [r for r in rules[lhs] if r != unit]

        self.rules = rules

    def hybrid_rule(self):
        """
        Eliminates terminals from the RHS of productions if they exist with other non-terminals or terminals.
        
        Returns:
        dict: The updated grammar rules with terminals eliminated from RHS.
        """
        rules = self.rules
        new_rules = {}
        terminal_to_var = {}

        for lhs, rhs_list in rules.items():
            new_rhs_list = []
            for rhs in rhs_list:
                if len(rhs) > 1:
                    new_rhs = []
                    for symbol in rhs:
                        if symbol.islower():  # If it's a terminal
                            if symbol not in terminal_to_var:
                                new_var = self.get_unique_nonterminal()
                                terminal_to_var[symbol] = new_var
                                if new_var not in new_rules:
                                    new_rules[new_var] = [symbol]
                            new_rhs.append(terminal_to_var[symbol])
                        else:
                            new_rhs.append(symbol)
                    new_rhs_list.append("".join(new_rhs))
                else:
                    new_rhs_list.append(rhs)
            if lhs not in new_rules:
                new_rules[lhs] = []
            new_rules[lhs].extend(new_rhs_list)

        # Ensure 'S' is the first key in the new_rules dictionary
        if 'S' in new_rules:
            s_rules = new_rules.pop('S')
            new_rules = {'S': s_rules, **new_rules}

        self.rules = new_rules


    def non_binary_rule(self):
        """
        Eliminates productions with more than two non-terminals on the RHS.
        
        Returns:
        dict: The updated grammar rules with RHS having at most two non-terminals.
        """
        rules = self.rules
        new_rules = {}

        for lhs, rhs_list in rules.items():
            new_rhs_list = []
            for rhs in rhs_list:
                while len(rhs) > 2:
                    new_var = self.get_unique_nonterminal()
                    new_rules[new_var] = [rhs[-2:]]
                    rhs = rhs[:-2] + new_var
                new_rhs_list.append(rhs)
            if lhs not in new_rules:
                new_rules[lhs] = []
            new_rules[lhs].extend(new_rhs_list)

        self.rules = new_rules

    def is_binary(self):
        """
        Checks if all productions have at most two non-terminal symbols in the RHS.
        
        Returns:
        bool: True if all productions have at most two non-terminal symbols in the RHS, False otherwise.
        """
        for rhs_list in self.rules.values():
            for rhs in rhs_list:
                non_terminals = [symbol for symbol in rhs if symbol.isupper()]
                if len(non_terminals) > 2:
                    return False
        return True

    def transform_to_CNF(self):
        """
        Transforms the grammar to Chomsky Normal Form (CNF).
        
        Returns:
        dict: The CNF grammar rules.
        """
        self.remove_null_productions()
        self.unitary_rule()
        self.hybrid_rule()
        while not self.is_binary():
            self.non_binary_rule()
        return self.rules

    def get_cnf_grammar(self):
        return self.cnf_grammar

def read_input_file(file_path):
    """
    Reads a file containing grammars and words, and organizes them into a list of tuples.
    
    Args:
    file_path (str): The path to the input file.
    
    Returns:
    list of tuples: Each tuple contains a list of grammar rules and a list of words.
    """
    grammars_and_words = []
    with open(file_path, 'r') as file:
        lines = file.readlines()
        
        grammar = []
        words = []
        for line in lines:
            line = line.strip()
            if not line:
                if grammar and words:
                    grammars_and_words.append((grammar, words))
                    grammar = []
                    words = []
            elif '->' in line:
                grammar.append(line)
            else:
                words.append(line)
        
        if grammar and words:
            grammars_and_words.append((grammar, words))
    
    return grammars_and_words

def write_output_file(output_path, results):
    """
    Writes the results of the CKY algorithm to an output file.
    
    Args:
    output_path (str): The path to the output file.
    results (list of tuples): Each tuple contains a list of grammar rules 
                              and a list of results.
    """
    with open(output_path, 'w') as file:
        file.write("=" * 50 + "\n")
        for grammar, words_results in results:
            file.write("Grammar:\n")
            for rule in grammar:
                file.write(rule + "\n")
            file.write("\n")
            file.write("Results:\n")
            for word, result in words_results:
                file.write(f"{word}: {'True' if result else 'False'}\n")
            file.write("\n")
            file.write("=" * 50 + "\n")

def main():
    """
    Main function to read input, check if grammars are in CNF, execute the CKY algorithm, and write the output.
    """
    input_file_path = 'input.txt'
    output_file_path = 'output.txt'
    grammars_and_words = read_input_file(input_file_path)
    results = []

    for grammar, words in grammars_and_words:
        cfg = CFG(grammar)
        if not cfg.is_cnf:
            grammar = cfg.cnf_grammar
        
        words_results = []
        for word in words:
            result = cfg.cky_algorithm(word)
            words_results.append((word, result))
        
        results.append((grammar, words_results))
    
    write_output_file(output_file_path, results)
    print("Output written to 'output.txt'")

if __name__ == "__main__":
    main()
