from transform_into_cnf import CNF

class PCFG():
    def __init__(self, grammar):
        self.grammar = grammar
        self.rules = self.parse_probabilistic_grammar(grammar)


    
    def parse_probabilistic_grammar(self, grammar):
        """
        Parses the probabilistic grammar rules from a list of strings.
        
        Args:
        grammar (list of str): The list of grammar rules in the form "LHS -> RHS probability".
        
        Returns:
        dict: A dictionary where keys are the left-hand side (LHS) of the rules
            and values are tuples of right-hand side (RHS) alternatives and their probabilities.
        """
        rules = {}
        for rule in grammar:
            lhs, rhs = rule.split("->")
            lhs = lhs.strip()
            rhs, prob = rhs.rsplit(' ', 1)
            rhs = [r.strip() for r in rhs.split("|")]
            rules[lhs] = (rhs, float(prob))
        return rules


    def cky_algorithm(self, word):
        """
        Implements the Cocke-Kasami-Younger (CKY) algorithm to determine if a word 
        can be generated by a given grammar.

        Args:
        word (str): The word to be tested.

        Returns:
        bool: True if the word can be generated by the grammar, False otherwise.
        """
        rules = self.rules  # Use the CNF grammar
        n = len(word)
        table = [[{} for _ in range(n)] for _ in range(n)]  # Change to store probabilities

        # Fill the diagonal of the table
        for j in range(n):
            for lhs, (rhs_list, prob) in rules.items():  # Unpack probability
                for rhs in rhs_list:
                    if rhs == word[j]:
                        table[j][j][lhs] = prob  # Store probability



        # Fill the rest of the table
        for span in range(2, n + 1):
            for i in range(n - span + 1):
                j = i + span - 1
                for k in range(i, j):
                    for lhs, (rhs_list, prob) in rules.items():  # Unpack probability
                        for rhs in rhs_list:
                            if len(rhs) == 2:
                                B, C = rhs
                                if B in table[i][k] and C in table[k + 1][j]:
                                    # Calculate new probability
                                    new_prob = table[i][k][B] * table[k + 1][j][C] * prob
                                    # Update if this is a higher probability
                                    if lhs not in table[i][j] or new_prob > table[i][j][lhs]:
                                        table[i][j][lhs] = new_prob

        return ['S' in table[0][n-1], table]

