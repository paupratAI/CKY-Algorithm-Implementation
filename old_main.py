def parse_grammar(grammar):
    """
    Parses the grammar rules from a list of strings.
    
    Args:
    grammar (list of str): The list of grammar rules in the form "LHS -> RHS".
    
    Returns:
    dict: A dictionary where keys are the left-hand side (LHS) of the rules
          and values are lists of right-hand side (RHS) alternatives.
    """
    rules = {}
    for rule in grammar:
        lhs, rhs = rule.split("->")
        lhs = lhs.strip()
        rhs = [r.strip() for r in rhs.split("|")]
        rules[lhs] = rhs
    return rules

def is_cnf(grammar):
    """
    Checks if the given grammar is in Chomsky Normal Form (CNF).
    
    Args:
    grammar (list of str): The list of grammar rules.
    
    Returns:
    bool: True if the grammar is in CNF, False otherwise.
    """
    rules = parse_grammar(grammar)
    for lhs, rhs_list in rules.items():
        for rhs in rhs_list:
            if len(rhs) == 1:
                # Single terminal symbol (must be lowercase)
                if len(rhs[0]) == 1:
                    if not rhs[0].islower():  # rhs is a single terminal
                        return False
            elif len(rhs) == 2:
                # Two symbols (one must be a terminal and the other a non-terminal)
                is_first_upper = any(char.isupper() for char in rhs[0])
                is_second_upper = any(char.isupper() for char in rhs[1])
                if (rhs[0].islower() and is_second_upper) or (rhs[1].islower() and is_first_upper):
                    return False
            else:
                return False  # If there are more than 2 symbols on the right hand side, it's not CNF
    return True  # If all checks passed, it's CNF

def cky_algorithm(grammar, word):
    """
    Implements the Cocke-Kasami-Younger (CKY) algorithm to determine if a word 
    can be generated by a given grammar.
    
    Args:
    grammar (list of str): The list of grammar rules.
    word (str): The word to be tested.
    
    Returns:
    bool: True if the word can be generated by the grammar, False otherwise.
    """
    rules = parse_grammar(grammar)
    n = len(word)
    table = [[set() for _ in range(n)] for _ in range(n)]
    
    # Fill the diagonal of the table
    for j in range(n):
        for lhs, rhs_list in rules.items():
            for rhs in rhs_list:
                if rhs == word[j]:
                    table[j][j].add(lhs)
        
        # Handle unit productions
        added = True
        while added:
            added = False
            for lhs, rhs_list in rules.items():
                for rhs in rhs_list:
                    if len(rhs) == 1 and rhs in table[j][j]:
                        if lhs not in table[j][j]:
                            table[j][j].add(lhs)
                            added = True
    
    # Fill the rest of the table
    for span in range(2, n + 1):  # span length
        for i in range(n - span + 1):
            j = i + span - 1
            for k in range(i, j):
                for lhs, rhs_list in rules.items():
                    for rhs in rhs_list:
                        if len(rhs) == 2:
                            B, C = rhs
                            if B in table[i][k] and C in table[k + 1][j]:
                                table[i][j].add(lhs)
            
            # Handle unit productions
            added = True
            while added:
                added = False
                for lhs, rhs_list in rules.items():
                    for rhs in rhs_list:
                        if len(rhs) == 1 and rhs in table[i][j]:
                            if lhs not in table[i][j]:
                                table[i][j].add(lhs)
                                added = True
    
    return 'S' in table[0][n-1]

def read_input_file(file_path):
    """
    Reads a file containing grammars and words, and organizes them into a list of tuples.
    
    Args:
    file_path (str): The path to the input file.
    
    Returns:
    list of tuples: Each tuple contains a list of grammar rules and a list of words.
    """
    grammars_and_words = []
    with open(file_path, 'r') as file:
        lines = file.readlines()
        
        grammar = []
        words = []
        for line in lines:
            line = line.strip()
            if not line:
                if grammar and words:
                    grammars_and_words.append((grammar, words))
                    grammar = []
                    words = []
            elif '->' in line:
                grammar.append(line)
            else:
                words.append(line)
        
        if grammar and words:
            grammars_and_words.append((grammar, words))
    
    return grammars_and_words

def write_output_file(output_path, grammars_and_words):
    """
    Writes the results of the CKY algorithm to an output file.
    
    Args:
    output_path (str): The path to the output file.
    grammars_and_words (list of tuples): Each tuple contains a list of grammar rules 
                                         and a list of words.
    """
    with open(output_path, 'w') as file:
        for grammar, words in grammars_and_words:
            file.write("Grammar:\n")
            for rule in grammar:
                file.write(rule + "\n")
            file.write("Results:\n")
            for word in words:
                result = cky_algorithm(grammar, word)
                file.write(f"{word}: {result}\n")
            file.write("\n")

def transform_to_CNF(grammar):
    """
    Transforms a grammar into Chomsky Normal Form.
    
    Args:
    grammar (list of str): A list of grammar rules.
    
    Returns:
    list of str: The grammar in Chomsky Normal Form.
    """
    def split_rule(rule): # Splits a rule into its left-hand side and right-hand side parts.
        lhs, rhs = rule.split(' -> ')
        rhs_parts = rhs.split(' | ')
        return lhs, rhs_parts

    def non_binary_rules_completed(grammar): # Checks if all rules in the grammar are binary.
        for rule in grammar:
            lhs, rhs_parts = split_rule(rule)
            if len(rhs_parts) > 2:
                return False
        return True
    
    def get_unique_nonterminal(existing_nonterminals):
        for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
            if letter not in existing_nonterminals:
                existing_nonterminals.add(letter)
                return letter, existing_nonterminals
        raise ValueError("Ran out of unique non-terminal symbols")
    
    def non_binary_rules(grammar, existing_nonterminals): # Transforms non-binary rules into binary rules.
        new_grammar = []
        
        for rule in grammar:
            lhs, rhs_parts = split_rule(rule)
            existing_nonterminals.add(lhs)

        for rule in grammar:
            lhs, rhs_parts = split_rule(rule)

            if len(rhs_parts) <= 2:
                new_grammar.append(rule)
            else:
                symbol1= rhs_parts[0]
                symbol2, existing_nonterminals = get_unique_nonterminal(existing_nonterminals)
                new_grammar.append(f'{lhs} -> {symbol1} | {symbol2}')
                new_grammar.append(f'{symbol2} -> {" | ".join(rhs_parts[1:])}')
        return new_grammar, existing_nonterminals

    def hybrid_and_unitary_rules(grammar, existing_nonterminals): # Transforms hybrid and unitary rules into CNF.
        new_rules = []
        non_terminal_id = 0
        terminal_to_nonterminal = {}
        rules = parse_grammar(grammar)
        terminals_used = set()

        for rule in grammar:
            lhs, rhs_parts = split_rule(rule)
            existing_nonterminals.add(lhs)

        for rule in grammar:
            lhs, rhs_parts = split_rule(rule)
            
            # Hybrid rule
            if len(rhs_parts) == 2: 
                new_rhs_parts = []
                for symbol in rhs_parts:
                    new_part = []
                    if symbol.islower():  # It's a terminal
                        if symbol not in terminal_to_nonterminal:
                            new_nonterminal, existing_nonterminals  = get_unique_nonterminal(existing_nonterminals)
                            terminal_to_nonterminal[symbol] = new_nonterminal
                            new_rules.append(f'{new_nonterminal} -> {symbol}')
                            non_terminal_id += 1
                        new_part.append(terminal_to_nonterminal[symbol])
                    else:  # It's a non-terminal
                        new_part.append(symbol)
                    new_rhs_parts.append(''.join(new_part))
                new_rules.append(f'{lhs} -> {" | ".join(new_rhs_parts)}')
            
            # Unitary rule
            elif len(rhs_parts) == 1: # Just 1 rhs
                symbol = rhs_parts[0]   
                if len(symbol) == 1: # It's a unitary rule
                    if symbol.islower(): # terminal
                        if symbol not in terminals_used:
                            new_rules.append(f'{lhs} -> {symbol}')
                    else: # non terminal
                        if len(rules[symbol]) == 1: # REGLA UNITARIA
                            terminal_symbol = rules[symbol][0]
                            new_rules.append(f'{lhs} -> {terminal_symbol}')
                            terminals_used.add(terminal_symbol)
                        else:
                            new_rules.append(f'{lhs} -> {symbol}')
                            new_rules.append(f'{symbol} -> {rules[symbol]}')
                else:
                    new_rules.append(f'{lhs} -> {symbol}')
        return new_rules

    new_grammar = grammar.copy()

    # Transform non-binary rules into binary rules
    existing_nonterminals = set()
    while not non_binary_rules_completed(new_grammar):
        new_grammar, existing_nonterminals = non_binary_rules(new_grammar, existing_nonterminals)

    # Transform hybrid and unitary rules into Chomsky Normal Form
    new_grammar = hybrid_and_unitary_rules(new_grammar, existing_nonterminals)
    return new_grammar

def main():
    """
    Main function to read input, check if grammars are in CNF, execute the CKY algorithm, and write the output.
    """
    input_file_path = 'input.txt'
    output_file_path = 'output.txt'
    grammars_and_words = read_input_file(input_file_path)

    with open(output_file_path, 'w') as file:
        for grammar, words in grammars_and_words:
            file.write("Grammar:\n")
            if not is_cnf(grammar):
                file.write("Converted into CNF" + "\n")
                grammar = transform_to_CNF(grammar)
                
            for rule in grammar:
                file.write(rule + "\n")
            
            file.write("Results:\n")
            for word in words:
                result = cky_algorithm(grammar, word)
                file.write(f"{word}: {result}\n")
            file.write("\n")
    
    print(f"Results written to {output_file_path}")

if __name__ == "__main__":
    main()
