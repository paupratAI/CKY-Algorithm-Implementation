class CFG():
    def __init__(self, grammar):
        self.grammar = grammar
        self.rules = self.parse_grammar(grammar)
        self.is_cnf = self.check_if_cnf()
        self.cnf_grammar = None
        if not self.is_cnf:
            self.cnf_grammar = CNF(self.grammar).get_cnf_grammar()
    
    def parse_grammar(self, grammar):
        """
        Parses the grammar rules from a list of strings.
        
        Args:
        grammar (list of str): The list of grammar rules in the form "LHS -> RHS".
        
        Returns:
        dict: A dictionary where keys are the left-hand side (LHS) of the rules
              and values are lists of right-hand side (RHS) alternatives.
        """
        rules = {}
        for rule in grammar:
            lhs, rhs = rule.split("->")
            lhs = lhs.strip()
            rhs = [r.strip() for r in rhs.split("|")]
            rules[lhs] = rhs
        return rules

    def check_if_cnf(self):
        """
        Checks if the given grammar is in Chomsky Normal Form (CNF).
        
        Returns:
        bool: True if the grammar is in CNF, False otherwise.
        """
        rules = self.rules
        for lhs, rhs_list in rules.items():
            for rhs in rhs_list:
                if len(rhs) == 1:
                    # Single terminal symbol (must be lowercase)
                    if not rhs.islower():  # rhs is a single terminal
                        return False
                elif len(rhs) == 2:
                    # Two symbols (both must be non-terminals)
                    if not (rhs[0].isupper() and rhs[1].isupper()):
                        return False
                else:
                    return False  # If there are more than 2 symbols on the right-hand side, it's not CNF
        return True  # If all checks passed, it's CNF

    def cky_algorithm(self, word):
        """
        Implements the Cocke-Kasami-Younger (CKY) algorithm to determine if a word 
        can be generated by a given grammar.

        Args:
        word (str): The word to be tested.

        Returns:
        bool: True if the word can be generated by the grammar, False otherwise.
        """
        rules = self.rules
        n = len(word)
        table = [[set() for _ in range(n)] for _ in range(n)]

        # Fill the diagonal of the table
        for j in range(n):
            for lhs, rhs_list in rules.items():
                for rhs in rhs_list:
                    if rhs == word[j]:
                        table[j][j].add(lhs)

            # Handle unit productions
            added = True
            while added:
                added = False
                for lhs, rhs_list in rules.items():
                    for rhs in rhs_list:
                        if len(rhs) == 1 and rhs in table[j][j]:
                            if lhs not in table[j][j]:
                                table[j][j].add(lhs)
                                added = True

        # Fill the rest of the table
        for span in range(2, n + 1):
            for i in range(n - span + 1):
                j = i + span - 1
                for k in range(i, j):
                    for lhs, rhs_list in rules.items():
                        for rhs in rhs_list:
                            if len(rhs) == 2:
                                B, C = rhs
                                if B in table[i][k] and C in table[k + 1][j]:
                                    table[i][j].add(lhs)

                # Handle unit productions
                added = True
                while added:
                    added = False
                    for lhs, rhs_list in rules.items():
                        for rhs in rhs_list:
                            if len(rhs) == 1 and rhs in table[i][j]:
                                if lhs not in table[i][j]:
                                    table[i][j].add(lhs)
                                    added = True
        
        return 'S' in table[0][n-1]


class CNF():
    def __init__(self, grammar):
        self.grammar = grammar
        self.rules = self.parse_grammar(grammar)
        self.cnf_grammar = self.transform_to_CNF()
    
    def parse_grammar(self, grammar):
        """
        Parses the grammar rules from a list of strings.
        
        Args:
        grammar (list of str): The list of grammar rules in the form "LHS -> RHS".
        
        Returns:
        dict: A dictionary where keys are the left-hand side (LHS) of the rules
              and values are lists of right-hand side (RHS) alternatives.
        """
        rules = {}
        for rule in grammar:
            lhs, rhs = rule.split("->")
            lhs = lhs.strip()
            rhs = [r.strip() for r in rhs.split("|")]
            rules[lhs] = rhs
        return rules




    def transform_to_CNF(self):
        pass

    def get_cnf_grammar(self):
        return self.cnf_grammar


# Ejemplo de uso:
grammar = [
    "S -> aX | bY",
    "X -> aX | bS | ε",
    "Y -> aY | bY | ε"
]

grammar2 = [
    "S -> a | XA | AX | b",
    "A -> RB",
    "B -> AX | b | a",
    "X -> a",
    "R -> XB"
]

cfg = CFG(grammar)

if not cfg.is_cnf:
    print("La gramática no está en FNC. Transformando a FNC...")
    cnf = cfg.cnf_grammar
    for rule in cnf:
        print(rule)
else:
    print("La gramática ya está en FNC.")


'''
    def transform_to_CNF(self):
        """
        Transforms a grammar into Chomsky Normal Form.
        
        Returns:
        list of str: The grammar in Chomsky Normal Form.
        """
        def split_rule(rule):
            lhs, rhs = rule.split(' -> ')
            rhs_parts = rhs.split(' | ')
            return lhs, rhs_parts
        
        def non_binary_rules_completed(grammar):
            for rule in grammar:
                lhs, rhs_parts = split_rule(rule)
                if len(rhs_parts) > 2:
                    return False
            return True
        
        def get_unique_nonterminal(existing_nonterminals):
            for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
                if letter not in existing_nonterminals:
                    existing_nonterminals.add(letter)
                    return letter, existing_nonterminals
            raise ValueError("Ran out of unique non-terminal symbols")
        
        def non_binary_rules(grammar, existing_nonterminals):
            new_grammar = []
            
            for rule in grammar:
                lhs, rhs_parts = split_rule(rule)
                existing_nonterminals.add(lhs)

            for rule in grammar:
                lhs, rhs_parts = split_rule(rule)

                if len(rhs_parts) <= 2:
                    new_grammar.append(rule)
                else:
                    symbol1= rhs_parts[0]
                    symbol2, existing_nonterminals = get_unique_nonterminal(existing_nonterminals)
                    new_grammar.append(f'{lhs} -> {symbol1} | {symbol2}')
                    new_grammar.append(f'{symbol2} -> {" | ".join(rhs_parts[1:])}')
            return new_grammar, existing_nonterminals
        
        def hybrid_and_unitary_rules(grammar, existing_nonterminals):
            new_rules = []
            non_terminal_id = 0
            terminal_to_nonterminal = {}
            rules = self.rules
            terminals_used = set()

            for rule in grammar:
                lhs, rhs_parts = split_rule(rule)
                existing_nonterminals.add(lhs)

            for rule in grammar:
                lhs, rhs_parts = split_rule(rule)
                
                if len(rhs_parts) == 2:
                    new_rhs_parts = []
                    for symbol in rhs_parts:
                        new_part = []
                        if symbol.islower():
                            if symbol not in terminal_to_nonterminal:
                                new_nonterminal, existing_nonterminals  = get_unique_nonterminal(existing_nonterminals)
                                terminal_to_nonterminal[symbol] = new_nonterminal
                                new_rules.append(f'{new_nonterminal} -> {symbol}')
                                non_terminal_id += 1
                            new_part.append(terminal_to_nonterminal[symbol])
                        else:
                            new_part.append(symbol)
                        new_rhs_parts.append(''.join(new_part))
                    new_rules.append(f'{lhs} -> {" | ".join(new_rhs_parts)}')
                
                elif len(rhs_parts) == 1:
                    symbol = rhs_parts[0]   
                    if len(symbol) == 1:
                        if symbol.islower():
                            if symbol not in terminals_used:
                                new_rules.append(f'{lhs} -> {symbol}')
                        else:
                            if len(rules[symbol]) == 1:
                                terminal_symbol = rules[symbol][0]
                                new_rules.append(f'{lhs} -> {terminal_symbol}')
                                terminals_used.add(terminal_symbol)
                            else:
                                new_rules.append(f'{lhs} -> {symbol}')
                                new_rules.append(f'{symbol} -> {rules[symbol]}')
                    else:
                        new_rules.append(f'{lhs} -> {symbol}')
            return new_rules

        new_grammar = self.grammar.copy()

        existing_nonterminals = set()
        while not non_binary_rules_completed(new_grammar):
            new_grammar, existing_nonterminals = non_binary_rules(new_grammar, existing_nonterminals)

        new_grammar = hybrid_and_unitary_rules(new_grammar, existing_nonterminals)
        return new_grammar
        '''